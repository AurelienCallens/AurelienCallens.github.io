{
  "hash": "8880accf381182353c349878f1222adf",
  "result": {
    "markdown": "---\ntitle: \"Can R and Shiny make me a better fisherman? Part 1\"\nsubtitle: \"Building a shiny application to store my fishing data\"\nauthor: \"Aurélien Callens\"\ndate: \"2020-09-12\"\nexecute:\n  freeze: true\nimage: images/seabass_bay.jpg\ntoc: true\ncategories:\n  - R\n  - Shiny\n  - Web scraping\n---\n\n\n\n\n\nMy favorite hobby, in addition to R coding of course, is fishing. Most of the time, I fish European sea bass (*Dicentrarchus labrax*) in estuaries. The sea bass is a predatory fish that has a broad range of preys: crabs, sand eels, prawns, shrimps and other fish. To catch these predators, I don't use live baits, I prefer to use artificial lures that imitate a specific prey. \n\nIn theory, it is quite easy to catch a fish:\n\n  1. Use a lure that imitate the current prey of the sea bass.\n\n  2. Animate the lure in a spot where the fish are active.\n\n  3. Catch a really big fish ! \n\nIn practice, it is an other story ! Indeed, the feeding activity, the position of the European sea bass in the estuary and their preys will vary depending on different parameters: \n\n  * the characteristics of the riverbed, which will depend where I fish\n  * the time of the day: the sea bass is more active during dawn and dusk\n  * the current and water level associated with the tide. The water level in estuaries is constantly varying to greater or lesser degree due to the tide influence. It is also influenced by the river flow which can be higher in case of heavy rains. \n\nAs you understand, there are many parameters potentially influencing the results of my fishing session. This is why I decided to create a shiny application to augment the number and the length of the fish caught during my sessions. To reach this objective, I need to better understand the activity, the position and the prey of the sea bass depending on the parameters described above. \n\n## Requirements of my application \n\n  + It must store data about my fishing session:\n\n\n| Information needed | Description of the variables  | Where do I get the data ? |\n|-|-|-|\n| Time | Time when a fish is caught, time since the beginning of the session | R |\n| Catch | Species and length of the fish caught | Geolocation from smartphone? |\n| Lures | Type, length, color of lure used  | Weather API |\n\n\n  + It must record data about my catch and the artificial lures used: \n\n| Information needed | Description of the variables | Where do I get the data ? |\n|-|-|-|\n| Time | Time when a fish is caught, time since the beginning of the session | R |\n| Catch | Species and length of the fish caught | User input |\n| Lures | Type, length, color of lure used | User input |\n\n  + It must be adapted to small screens because I will always use the application on my phone. \n\n  + It must remain free.\n\n\n## Collecting the data \n\n### Getting my gps location \n\nMy gps location is collected by using a bit of Javascript in the header of the shiny application. This code has been developed by AugusT and is available on his <a href=\"https://github.com/AugustT/shiny_geolocation\" target=\"_blank\">github repository</a>. \n\n### Weather API\n\nFor the weather data, I found a free API called Dark Sky. I made a function that takes as input the coordinates of a place and the API user key and returns the current weather conditions in a dataframe: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\nlibrary(rvest)\n\nweather <- function(x, API_key){\n  url <- paste0(\"https://api.darksky.net/forecast/\",API_key,\n                \"/\", x[1], \",\", x[2],\n                \"?units=ca&exclude=hourly,alerts,flags\")\n  \n  rep <- GET(url)\n  \n  table <- fromJSON(content(rep, \"text\"))\n  \n  current.weather.info <- with(table,\n                               data.frame(Air_temp = currently$temperature,\n                                     Weather = currently$summary,\n                                     Atm_pres = currently$pressure,\n                                     Wind_str = currently$windSpeed,\n                                     Wind_dir = currently$windBearing,\n                                     Cloud_cover = currently$cloudCover,\n                                     PrecipProb = currently$precipProbability,\n                                     PrecipInt = currently$precipIntensity,  \n                                     Moon = daily$data$moonPhase[1]))\n  return(current.weather.info)\n}\n```\n:::\n\n\n\n### Web scrapping for Tide data\n\nI created a function to scrap information about the tide on a french website. The following function takes no argument and return the current water level, the tide status (going up or down) and time since the tide peak for the location I fish.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntide <- function(){\n  \n  # Set the current time and time zone \n  Sys.setenv(TZ=\"Europe/Paris\")\n  time <- as.POSIXct(Sys.time())\n  url <- \"https://services.data.shom.fr/hdm/vignette/grande/BOUCAU-BAYONNE?locale=en\"\n  \n  # Read the web page that contains the tide data \n  text <- url %>% \n    read_html() %>%\n    html_text()\n  \n  # Clean the html data to get a dataframe  with two cols Time and water level: \n\n  text <- as.character(sub(\".*var data = *(.*?) *\\\\;.*\", \"\\\\1\", text))\n  text <- unlist(str_split( substr(text, 1, nchar(text)-2), \"\\\\],\"))\n  tidy_df <- data.frame(hour=NA,Water=NA)\n  \n  for(i in 1:length(text)){\n    text_dat <- unlist(str_split(text[i], '\"'))[c(2,3)]\n    text_dat[1] <- substr(text_dat[1], 1, nchar(text_dat[1])-1)\n    text_dat[2] <- as.numeric(substr(text_dat[2], 2, nchar(text_dat[2])))\n    tidy_df[i,] <- text_dat\n  }\n  \n  tidy_df$hour <- as.POSIXct(paste(format(Sys.time(),\"%Y-%m-%d\"), tidy_df$hour))\n  \n  # Some lines to get the tide status (going down or up) : \n  \n  n_closest <- which(abs(tidy_df$hour - time) == min(abs(tidy_df$hour - time)))\n  \n  water_level <- as.numeric(tidy_df[n_closest, 2])\n  \n  all_decrea <- all(tidy_df$Water[(n_closest-6):(n_closest+6)] ==\n                      cummin(tidy_df$Water[(n_closest-6):(n_closest+6)] ))\n  \n  all_increa <- all(tidy_df$Water[(n_closest-6):(n_closest+6)] ==\n                      cummax(tidy_df$Water[(n_closest-6):(n_closest+6)] ))\n  \n  maree <- ifelse(all_decrea, \"Down\", ifelse(all_increa, \"Up\", \"Dead\"))\n  \n  \n  # Compute time since the last peak :\n  \n  last_peak <- max(cumsum(rle(diff(as.numeric(tidy_df$Water), lag = 2) > 0)$lengths)\n                   [cumsum(rle(diff(as.numeric(tidy_df$Water), lag = 2) >0)$lengths) < n_closest])\n  \n  \n  time_after <- as.numeric(difftime(tidy_df$hour[n_closest], tidy_df$hour[last_peak], units = \"mins\"))\n  \n  \n  # Return the list with the results :\n  \n  return(list(Water_level = water_level,\n              Maree = maree,\n              Time_peak = time_after))\n  \n}\n```\n:::\n\n\n\n## The shiny application\n\nThe main problem I encountered while developing this application was data storage. Shinyapps.io\nhost freely your shiny application but there were some problems when I used the shiny application to modify the csv files. \nThe solution I found was to store the data in my dropbox account, you can find <a href=\"https://shiny.rstudio.com/articles/persistent-data-storage.html\" target=\"_blank\">here</a> more details on the subject and alternatives solutions. I used the package *rdrop2* to access and modify the data with the shiny application. \n\n\nHere are the main steps of this application : \n\n1. When the application is started, it reads a csv file stored on my dropbox to see if a fishing session is running or not. If not the user can start a fishing session. \n\n2. When starting a new session, a line with coordinates, weather conditions, and tide condition is added to the csv file previously mentioned.  \n\n3. If a fish is caught, the user can fill out a form to store the data in a second csv file. This file contains : the time, the species and length of the fish and information about the fishing lure used (type, color, length). \n\n4. The user can end the fishing session by pushing a button. This will register the ending time, weather conditions, and tide condition in the first csv file.  \n\nA simplified graph is showed below: \n\n\n\n\n\n![Simplified workflow of the application](images/graph.svg)\n\n\n### UI side \n\nThe user interface of the application is built using the *miniUI* package. This package\nallows R user to develop shiny application adapted to small screens.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries \nlibrary(shiny)\nlibrary(shinyWidgets)\nlibrary(googlesheets)\nlibrary(miniUI)\nlibrary(leaflet)\nlibrary(rdrop2)\nSys.setenv(TZ=\"Europe/Paris\")\n\n#Import the functions for weather API and webscrapping \nsuppressMessages(source(\"api_functions.R\"))\n\n\n# Load the dropbox token : \ntoken <<- readRDS(\"token.rds\")\n\n# Minipage for small screens\nui <- miniPage(\n  # Javascript that give user location (input$lat,input$long)\n  tags$script('$(document).ready(function () {\n                           navigator.geolocation.getCurrentPosition(onSuccess, onError);\n                           \n                           function onError (err) {\n                           Shiny.onInputChange(\"geolocation\", false);\n                           }\n                           \n                           function onSuccess (position) {\n                           setTimeout(function () {\n                           var coords = position.coords;\n                           console.log(coords.latitude + \", \" + coords.longitude);\n                           Shiny.onInputChange(\"geolocation\", true);\n                           Shiny.onInputChange(\"lat\", coords.latitude);\n                           Shiny.onInputChange(\"long\", coords.longitude);\n                           }, 1100)\n                           }\n                           });'),\n  \n  gadgetTitleBar(\"Catch them all\", left = NULL, right = NULL),\n  \n  miniTabstripPanel(\n    #First panel depends if a fishing session is started or not \n    miniTabPanel(\"Session\", icon = icon(\"sliders\"),\n                 miniContentPanel(uiOutput(\"UI_sess\", align = \"center\"),\n                                  uiOutput(\"UI\", align = \"center\"))\n    ),\n    # Second panel displays the location of the previous fishing session with the number of fish caught \n    miniTabPanel(\"Map\", icon = icon(\"map-o\"),\n                 miniContentPanel(scrollable = FALSE,padding = 0,\n                                  div(style=\"text-align:center\",\n                                      prettyRadioButtons(\"radio\", inline = TRUE, label = \"\",\n                                                         choices = list(\"3 dernières sessions\" = 1,\n                                                                        \"3 Meilleures Sessions\" = 2,\n                                                                        \"Tout afficher\" = 3), \n                                                         selected = 1)),\n                                  leafletOutput(\"map\", height = \"93%\")\n                 ))\n  )\n  \n)\n```\n:::\n\n\n\n### Server side \n\nThe server side is mainly composed by observeEvent functions. The utility of each \nobserveEvent is provided in the script as commentary. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session){\n  source(\"api_functions.R\")\n  \n  # Read the csv file containing information about fishing session. If a session is running,\n  # display the UI that allows the user to input data about the fish caught. If a session is not started,\n  # display a button to start the session.\n  \n  observeEvent(input$go ,{\n    \n    dat <<- drop_read_csv(\"/app_peche/session.csv\", header = T, stringsAsFactors = F, dtoken = token) \n    \n    output$UI<- renderUI({\n      tagList(\n        if(rev(dat$Status)[1] == \"end\"){\n          actionButton(\"go\",\"Start session\")}\n        else{\n          actionButton(\"go\",\"End session\") \n        }\n      )\n    })\n    \n    output$UI_sess<- renderUI({\n      if(rev(dat$Status)[1] == \"end\"){\n        tagList(textInput(\"comments\", label = h3(\"Commentaires\"), value = \"NA\"))\n      }else{\n        input$catch\n        \n        tagList(\n          selectInput(\"species\", label = h3(\"Espèces\"), \n                      choices = list(\"Bar\" = \"bar\", \n                                     \"Bar moucheté\" = \"bar_m\", \n                                     \"Alose\" = \"alose\",\n                                     \"Alose Feinte\" = \"alose_f\",\n                                     \"Maquereau\" = \"maquereau\", \n                                     \"Chinchard\" = \"chinchard\"), selected = \"bar\"),\n          \n          sliderInput(\"length\",label = h3(\"Taille du poisson\"),value=25,min=0,max=80, step=1),\n          \n          selectInput(\"lure\", label = h3(\"Type de leurre\"), \n                      choices = list(\"Shad\" = \"shad\",\n                                     \"Slug\" = \"slug\",\n                                     \"Jerkbait\" = \"jerkbait\",\n                                     \"Casting jig\" = \"jig\",\n                                     \"Topwater\" = \"topwater\"), selectize = FALSE),\n          \n          selectInput(\"color_lure\", label = h3(\"Couleur du leurre\"), \n                      choices = list(\"Naturel\" = \"naturel\",\n                                     \"Sombre\" = \"sombre\",\n                                     \"Clair\" = \"clair\",\n                                     \"Flashy\" = \"flashy\" ), selectize = FALSE),\n          \n          selectInput(\"length_lure\", label = h3(\"Taille du leurre\"), \n                      choices = list(\"Petit\" = \"petit\",\n                                     \"Moyen\" = \"moyen\",\n                                     \"Grand\" = \"grand\"), selectize = FALSE),\n          \n          actionButton(\"catch\",\"Rajoutez cette capture aux stats!\"),\n          \n          textInput(\"comments1\", label = h3(\"Commentaire avant la fin ?\"), value = \"NA\")\n          \n          \n        )\n        \n        \n      }\n      \n    })  \n    \n    \n  }, ignoreNULL = F)\n  \n  #If the button is pushed, create the line to be added in the csv file. \n  \n  observeEvent(input$go,{\n    \n    #Tide + geoloc + Weather\n    c_tide <- unlist(tide())\n    geoloc <- c(input$lat,input$long)\n    current.weather.info <- weather(geoloc) \n    \n    # Two outcomes depending if the session starts or ends. This gives the possibility \n    # to the user to add a comment before starting the session or after ending the session\n    \n    if(rev(dat$Status)[1] == \"end\"){\n      \n      n_ses <- c(rev(dat$Session)[1]+1)\n      stat_ses <- c(\"beg\")\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment <- input$comments\n      dat.f <- data.frame(n_ses, stat_ses, time_beg ,geoloc[2], geoloc[1], current.weather.info, c_tide[1], c_tide[2], c_tide[3], comment)\n      names(dat.f)<-names(dat)\n      a <- rbind(dat,dat.f)\n      \n    }else{\n      \n      n_ses <- c(rev(dat$Session)[1])\n      stat_ses <- c(\"end\")\n      time_beg <- as.character(as.POSIXct(Sys.time()))\n      comment1 <- input$comments1\n      dat.f<- data.frame(n_ses, stat_ses, time_beg ,geoloc[2], geoloc[1], current.weather.info, c_tide[1], c_tide[2], c_tide[3], comment1)\n      names(dat.f)<-names(dat)\n      a <- rbind(dat,dat.f)\n    }\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(a), \"session.csv\")\n    \n    # Upload it to dropbox account \n    drop_upload(\"session.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  \n  # Add a line to the catch csv file whenever a fish is caught\n  observeEvent(input$catch,{\n    caugth <- drop_read_csv(\"/app_peche/catch.csv\", header = T, stringsAsFactors = F, dtoken = token) \n    \n    n_ses <- c(rev(dat$Session)[1])\n    time <- as.POSIXct(Sys.time())\n    time_after_beg <- round(as.numeric(difftime(time, rev(dat$Time)[1], units = \"mins\")), digits = 0)\n    \n    catch <- data.frame(n_ses, \n                        time = as.character(time),\n                        min_fishing = as.character(time_after_beg),\n                        species = input$species,\n                        length = input$length,\n                        lure = input$lure,\n                        colour = input$color_lure,\n                        length_lure = input$length_lure)\n    \n    b <- rbind(caugth,catch)\n    \n    # Write csv in temporary files of shiny server \n    write_csv(as.data.frame(b), \"catch.csv\")\n    # Upload it to dropbox account \n    drop_upload(\"catch.csv\", path = \"App_peche\", mode = \"overwrite\", dtoken = token)\n  })\n  \n  # Create the map with the results of previous session depending on the choice of the user :\n  \n  observeEvent(input$radio,{\n    \n    output$map <- renderLeaflet({\n      map_data <- map_choice(input$radio)\n      leaflet(map_data) %>% addTiles() %>%\n        addPopups(lng = ~Long,\n                  lat = ~Lat, \n                  with(map_data,\n                       sprintf(\"<b>Session %.0f : %.1f h</b> <br/> %s <br/> %.0f  poissons <br/> hauteur d'eau: %.0f m, %s, %.0f min après l'étal\",\n                               n_ses,\n                               duration,\n                               Time,\n                               nb,\n                               Water_level,\n                               Tide_status,\n                               Tide_time)),\n                  options = popupOptions(maxWidth = 100, minWidth = 50))\n    })\n    \n  })\n  \n}\n```\n:::\n\n\n## Conclusion and future improvments\n\nYou can find a dummy example of this application (not linked to the dropbox account) \n<a href=\"https://aureliencallens.shinyapps.io/Dummy_angler_app/\" target=\"_blank\">here</a>.\nI have been using this application for 1 year without any problems! The data I collected will be presented in the next post. \n\nIn the coming months, I must find a new free API to replace the actual one. Indeed, the weather API I am using has been bought by Apple and the free requests will be stopped in the following year. \n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}